---
title: "High Performance Code with Rcpp"
author: "Paul W. Egeler, M.S., GStat"
date: "20 Mar 2018"
output:
  md_document:
    variant: markdown_github
  html_notebook:
    number_sections: yes
    toc: yes
    toc_float: yes
---

## Why use Rcpp?

The power of Rcpp comes from the fact the C++ code has a fundamentally different *modus operandi* than R. That is, C++ is compiled whereas R is interpreted. Understanding this difference is the key to understanding why an R user might want to rewrite parts of their code in an compiled language---namely that it will most likely run much faster. Leveraging C++ code at workflow bottlenecks is a great way to speed things up!

## Scripts versus compiled code

This talk is too high-level of a view to get into the gritty details, but here are the broad-brush definitions:

Scripting (Interpreted) Language

: A language where the user feeds instructions to an interpreter at run-time. The interpreter translates the code into specific instructions for the processor in real-time. The user can interface with the interpreter interactively. These programs tend to be slower than compiled code.

Compiled Language

: A programming language in which code must be transformed from human-readable *source code* to machine-readable *object code* in advance of running the program for the first time. These languages tend to be faster-running. However, interactive coding sessions are not usually possible.

Examples:

| **Scripting** | **Compiled** |
|:-------------:|:------------:|
| R             | C/C++        |
| Python        | Java         |
| Perl          | FORTRAN      |
| Matlab/Octave | Julia        |
| JavaScript    | Haskell      |

*__Note__: These definitions are somewhat fluid. Examples are based on common usage of each language.*

### Compiling code (outside of R)

If you have a compiler, creating object code is easy (but can get complicated!). Here is an example of how we turn a C++ source code file into a machine-readable binary program:

```bash
g++ heaps.cpp -o heaps
```

Now we can call that program:

```bash
# Get all possible permutations of the set {1,2,3} using Heap's algorithm
./heaps 1 2 3
##  1 2 3
##  2 1 3
##  3 1 2
##  1 3 2
##  2 3 1
##  3 2 1
```

### Quick sys-reqs note

Essentially, **R** is a **scripting language** and **`C`**/**`C++`** are **compiled languages**. This means that we can run any R code in an interpreter without any special preparation. However, any C++ code we make must be compiled first into machine-readable instructions specific to our chip architecture. To do this, we need a special tool called a *compiler*. Standard Windows and Mac installs don't tend to have one handy---this is why you download Windows binaries from CRAN by default. 

If you are a Windows user, you will probably need [Rtools](https://cran.r-project.org/bin/windows/Rtools/) to play along. Mac users need Xcode (I think). [`devtools`]() will let us know if we have everything we need:

```{r}
# Check to make sure we have everything we need
devtools::has_devel()
```

If this returns `FALSE`{.r}, go download Rtools or Xcode for Win or Mac, respectively.

## Basic C++ syntax



## R-specific C++ object classes

## Getting compiled code into your R scripts

### C-R API

TL;DR: Don't use it. The Rcpp API is a much easier way to write `C`/`C++` code for R. The exception might be if you are maintaining old code that is already in this ecosystem.

### The Rcpp API 

#### Prototyping and Packaging

You can prototype C++ code very easily using Rcpp. There are two ways you should be aware of:

- `Rcpp::cppFunction()`{.r}
    - Create functions in an interactive session.
    - The function takes a character string which is a C++ function definition.
    - Example [below](#a-basic-function)
- `Rcpp::sourceCpp()`{.r}
    - Much like `base::source()`{.r} but with C++ code
    - Also can be called interactively, but expects a separate file with (almost) pure C++ source code.
    - Rstudio has some cool features here. (We will do a live demo together.)

Once you have some solid functions, you might want to create a package to house and share them. The power of Rcpp really starts to shine when you start creating packages with it. After all, the idea of using compiled code in your R scripts is that it can help solve some speed bottlenecks. You are probably not going to optimize your code to be blazing-fast for a one-off problem. Therefore, this is code that you will probably want to recycle. You can use `Rcpp::Rcpp.package.skeleton()`{.r} to create a new package skeleton with some Rcpp niceties built in. Meanwhile, you can use `devtools::use_rcpp()`{.r} to add those niceties to an existing package. RcppArmadillo has `RcppArmadillo::RcppArmadillo.package.skeleton()`{.r} as well if you are interested in using the Armadillo C++ linear algebra library.

#### A basic function

```{r}
Rcpp::cppFunction('
void Hello_World (Rcpp::StringVector my_input) 
{
  Rcpp::Rcout << "Hello " << my_input(0) << "!";
}
')

Hello_World("WMRUG attendees")
```


#### 

### Data Structures


## Demonstrations

### Demo 1: Fibonacci Numbers

Fibonacci's Sequence:

$$
F_n = 
\begin{cases}
  1 ,                & \text{if } n\leq 2\\
  F_{n-1} + F_{n-2}, & \text{otherwise}
\end{cases}
$$

So the first 10 numbers of the sequence will be $1,1,2,3,5,8,13,21,34,55$.

This is fun because it is recursive. Therefore a programmer may take a recursive, memoized, or iterative approach to solving. We can use this to compare R and C++ under different conditions.

First, let's define a function to verify that our outputs are correct:

```{r}
verify_results <- function(FUN) {
  FUN_vec <- Vectorize(FUN, "n")
  
  identical(
    as.integer(FUN_vec(1:10)),
    c(1L, 1L, 2L, 3L, 5L, 8L, 13L, 21L, 34L, 55L)
  )
}
```

#### Recursive

Now, let's do a simple recursive function. First in R:

```{r}
fibR_rec <- function(n) {
  if (n <= 2)
    return(1)
  
  sys.function()(n - 1) + sys.function()(n - 2)
}
```

Then in C++:

```{r}
Rcpp::cppFunction("
int fibCpp_rec(const int n) {
  if (n <= 2)
    return 1;

  return fibCpp_rec(n - 1) + fibCpp_rec(n - 2);

}"
)
```

Now we confirm they are correct:

```{r}
verify_results(fibR_rec) && verify_results(fibCpp_rec)
```

Both are right. But how do they compare performance-wise?

```{r}
microbenchmark::microbenchmark(
  fibR_rec(10),
  fibCpp_rec(10),
  fibR_rec(20),
  fibCpp_rec(20)
)
```

OK, so the C++ wins here. This is because there is a lot of overhead to all those recursive function calls in R. Less so in C++. You will find that `for` loops and recursive function calls are usually the bottlenecks in your R code. If you cannot vectorize them somehow, you might want to think about making a C++ function to speed things up.

#### Iterative

The iterative approach is probably a little smarter. Let's try again in R:

```{r}
fibR_it <- function(n) {
  
  a <- 0L
  b <- 1L
  
  for (i in seq_len(n)) {
    c <- a + b
    a <- b
    b <- c
  }
  
  a
}
```


In C++...

```{r}
Rcpp::cppFunction("
int fibCpp_it(const int n) 
{
if (n <= 2) return 1;

int a = 0, b = 1, c = 0;

for (int i=1; i<n; i++)
{
  c = a + b;
  a = b;
  b = c;
}

return c;

}
")
```

And does the iterative approach provide correct answers?

```{r}
verify_results(fibR_it) && verify_results(fibCpp_it)
```

Now how do they compare as far as speed?

```{r}
microbenchmark::microbenchmark(
  fibR_it(10),
  fibCpp_it(10),
  times = 1000
)
```

Hmm. Suddenly the C++ code is lagging. This is probably because assignment is highly optimized in R and there is some overhead to calling the C++ function. Let's do it over a few more loops to see if that changes things:

```{r}
microbenchmark::microbenchmark(
  fibR_it(30),
  fibCpp_it(30)
)
```

Now we see the C++ code is catching up!

### Demo 2: Linear Algebra 

Follow the link: [`mvrt`](https://pegeler.github.io/mvrt)

## Links

- [`Rcpp`](https://github.com/RcppCore/Rcpp)
- [Seamless R and C++ Integration with Rcpp](http://www.springer.com/us/book/9781461468677)
- [`Armadillo`](https://github.com/conradsnicta/armadillo)
- [`RcppArmadillo`](https://github.com/RcppCore/RcppArmadillo)

